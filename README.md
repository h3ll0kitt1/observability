# Сервис сбора и отсылки метрик 

## Описание

Сервис состоит из агента, собирающего метрики и сервера, принимающего метрики от агента.

##  Агент

### Общее описание:

* Каждый фиксированный и заданный промежуток времени клиент в одной горутине обновляет метрики (причем в этой горутине он отдельно запускает еще одну для сбора метрик с помощью пакета gopsutil), в каждый другой фиксированный промежуток времени клиент конкурентно отсылает протоколу HTTP по одной метрике на сервер в заданном числе воркеров, предварительно сжав ее в формате gzip и добавив хедер с хешом от несжатых данных (если указан параметр ключа для клиента).
* Клиент отсылает метрики двух типов: gauge (`float64`), counter (`int64`).
* Для источника gauge метрик используется пакет runtime (`Alloc`, `BuckHashSys`, `Frees`, `GCCPUFraction`, `GCSys`, `HeapAlloc`, `HeapIdle`, `HeapInuse`, `HeapObjects`, `HeapReleased`, `HeapSys`, `LastGC`, `Lookups`, `MCacheInuse`, `MCacheSys`, `MSpanInuse`, `MSpanSys`, `Mallocs`, `NextGC`, `NumForcedGC`, `NumGC`, `OtherSys`, `PauseTotalNs`, `StackInuse`, `StackSys`, `Sys`, `TotalAlloс`), counter метрика -  `PollCount` - это  счётчик, увеличивающийся на 1 при каждом обновлении метрики из пакета runtime, `RandomValue` (тип gauge) — обновляемое произвольное значение, из пакета gopsutil собирать дополнительные метрики типа gauge: (`TotalMemory`, `FreeMemory`, `CPUutilization1`)
* Клиент только отсылает и никак не интересуется ответами от сервера.

###  Требуемая функциональность:

* Агент может принимать аргументы, с использованием флагов: 
  *	Флаг -a=<ЗНАЧЕНИЕ> отвечает за адрес эндпоинта HTTP-сервера (по умолчанию `localhost:8080`).
  *	Флаг -r=<ЗНАЧЕНИЕ> позволяет переопределять `reportInterval` — частоту отправки метрик на сервер (по умолчанию 10 секунд).
  *	Флаг -p=<ЗНАЧЕНИЕ> позволяет переопределять `pollInterval` — частоту опроса метрик из пакета runtime (по умолчанию 2 секунды).
  *	Флаг -k=<КЛЮЧ> позволяет установить ключ, используемый для подписания запроса, по умолчанию - отсуствует.
  *	Флаг -l=<ЗНАЧЕНИЕ> позволяет установит ограничение «сверху» на количество исходящих конкуретных запросов на сервер.

* При попытке передать приложению незвестные флаги оно должно завершаться с сообщением о соответствующей ошибке.
* Значения интервалов времени должны задаваться в секундах.

* Агент может изменять свои параметры запуска по умолчанию через переменные окружения:
  *	ADDRESS отвечает за адрес эндпоинта HTTP-сервера.
  *	REPORT_INTERVAL позволяет переопределять `reportInterval`.
  *	POLL_INTERVAL позволяет переопределять `pollInterval`.
  *	KEY позволяет переопределить ключ.
  *	RATE_LIMIT позволяет переопределить максимальное количество конкуретных запросов.

* Приоритет параметров должен быть таким:
	 * Если указана переменная окружения, то используется она.
   * Если нет переменной окружения, но есть аргумент командной строки (флаг), то используется он.
   * Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.
 
* Клиент передает метрики в формате JSON с использованием следующей структуры:
```go
  type Metrics struct {
     ID    string   `json:"id"`              // имя метрики
     MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
     Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
     Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
  }
```
*	Агент передает данные в формате gzip.
* При наличии ключа агент подписывает (HMAC) запрос  по алгоритму SHA256. Для этого он считает hash от всего тела запроса и размещает его в HTTP-заголовке HashSHA256.

###  Используемые пакеты:

* Для отправления запросов использовался пакет resty;
* Для кодирования данных в формате json использовался встроенный пакет encoding/json;
* Для сжатия данных в формате gzip использовался встроенный пакет compress/gzip;
* Для получения runtime метрик использовался пакет runtime;
* Для получения дополнительных метрик потребления памяти и CPU использовался пакет gopsutil;
* Для создания хеша от запроса использовались пакеты crypto/hmac, crypto/sha256, encoding/hex.

## Сервер:

### Общее описание:
* Сервер для сбора рантайм-метрик, который будет собирать репорты от агентов по протоколу HTTP.
* Принимать и хранить произвольные метрики двух типов: gauge (float64) — новое значение должно замещать предыдущее, counter (int64) — новое значение должно добавляться к предыдущему, если какое-то значение уже было известно серверу.
* Для контроля над синхронной и асинхронной записью создан интерфес `StorageManager`, то есть исходя из настроек приложения, либо будет использована асинхронная реализация, когда мы сбрасываем в бэкап (на диск/в файл) данные лишь спустя фиксированный промежуток времени, либо синхронная реализация, когда при поступлении новых данных мы сразу фиксируем их в бэкап.
* Для разграничения хранений, которые могут использоваться как бэкапы и как основное хранение - использованы интерфейсы - `MainStorage` и `BackupStorage`, где `MainStorage` - расширение `BackupStorage`, соответсвенно в случае необходимости, можно легко понять, что можно подменить и какой реализацией. 
* Сервер считает хеш от уже разжатых данных, если указан ключ как параметр конфигурации сервера. 

###  Требуемая функциональность:

* Ответы сервера:
  * При успешном приёме возвращать `http.StatusOK` и требуемые данные.
  * При попытке передать запрос без имени метрики или неизвестной серверу метрики возвращать `http.StatusNotFound`.
  * При попытке передать запрос с некорректным типом метрики или при несовпадении хеша вычисленного от запроса и хеша из хедера запроса сервер должен отбрасывать полученные данные значением возвращать `http.StatusBadRequest`.
* По запросу GET http://<АДРЕС_СЕРВЕРА>/ сервер должен отдавать HTML-страницу со списком имён и значений всех известных ему на текущий момент метрик.
* Должен уметь хранить метрики на выбор в оперативной памяти, и в SQL БД PostgreSQL.

*  Должен уметь с заданной периодичностью сохранять текущие значения метрик на диск в указанный файл, а на старте — опционально загружать сохранённые ранее значения. При штатном завершении сервера все накопленные данные должны сохраняться.

* Сервер должен уметь принимать аргументы с использованием флагов:
  * Флаг -a=<ЗНАЧЕНИЕ> отвечает за адрес эндпоинта HTTP-сервера (по умолчанию localhost:8080).
  * Флаг -d=<DATABASE_DSN> отвечает за адрес подключения к БД.
  * Флаг -i=<ЗНАЧЕНИЕ> — интервал времени в секундах, по истечении которого текущие показания сервера сохраняются на диск (по умолчанию 300 секунд, значение 0 делает запись синхронной).
  * Флаг -f=<ЗНАЧЕНИЕ> — полное имя файла, куда сохраняются текущие значения (по умолчанию /tmp/metrics-db.json, пустое значение отключает функцию записи на диск).
  * Флаг -r=<ЗНАЧЕНИЕ> — булево значение (true/false), определяющее, загружать или нет ранее сохранённые значения из указанного файла при старте сервера (по умолчанию true).
  * Флаг -k=<КЛЮЧ> позволяет установить ключ, используемый для подписания запроса, по умолчанию - отсуствует.
  * При попытке передать приложению незвестные флаги оно должно завершаться с сообщением о соответствующей ошибке.

* Сервер может изменять свои параметры запуска по умолчанию через переменные окружения:
  * ADDRESS отвечает за адрес эндпоинта HTTP-сервера.
  * DATABASE_DSN переопределяет адрес подключения к БД.
  * STORE_INTERVAL — интервал времени в секундах, по истечении которого текущие показания сервера сохраняются на диск (по умолчанию 300 секунд, значение 0 делает запись синхронной).
  * FILE_STORAGE_PATH — полное имя файла, куда сохраняются текущие значения (по умолчанию /tmp/metrics-db.json, пустое значение отключает функцию записи на диск).
  * RESTORE — булево значение (true/false), определяющее, загружать или нет ранее сохранённые значения из указанного файла при старте сервера (по умолчанию true).
  * KEY позволяет переопределить ключ.


* Приоритет параметров должен быть таким:
  * Если указана переменная окружения, то используется она.
  * Если нет переменной окружения, но есть аргумент командной строки (флаг), то используется он.
  * Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

* Должно производиться логирование сведений о запросах и ответах на сервере для всех эндпоинтов, которые у вас уже есть. 
  * Сведения о запросах должны содержать URI, метод запроса и время, затраченное на его выполнение.
  * Сведения об ответах должны содержать код статуса и размер содержимого ответа.
 
* Сервер должен обладать API позволяющим принимать метрики в формате JSON.
```go
  type Metrics struct {
     ID    string   `json:"id"`              // имя метрики
     MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
     Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
     Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
  }
```

* Сервер опционально может принимать запросы в сжатом формате (при наличии соответствующего HTTP-заголовка Content-Encoding).
* Отдавать сжатый ответ клиенту, который поддерживает обработку сжатых ответов (с HTTP-заголовком Accept-Encoding). Функция сжатия должна работать для контента с типами application/json и text/html.
* При наличии ключа во время обработки запроса сервер должен проверять соответствие полученного и вычисленного хеша. При наличии ключа на этапе формирования ответа сервер должен вычислять хеш и передавать его в HTTP-заголовке ответа с именем HashSHA256.

###  Используемые пакеты:

* Для роутинга запросов использовался пакет go-chi/chi;
* Для логирования использовался пакет go.uber.org/zap; 
* Для хранения использовалась СУБД PostgreSQL 15;
* Для кодирования и декодирования данных в формате json использовался встроенный пакет encoding/json;
* Для создания хеша от запроса использовались пакеты crypto/hmac, crypto/sha256, encoding/hex;
* Для сжатия данных в формате gzip использовался встроенный пакет compress/gzip.
